# src/ 	Verilog source file
# sim/ 	C++ test benches
# obj_dir/ (generated by Verilator)
#
# Usage:
#  make        # build simulator
#  make run    # run simulation
#  make clean  # clean generated files

VERILATOR ?= verilator
SRC_DIR   ?= src
SIM_DIR   ?= sim
OBJ_DIR   ?= obj_dir
WAVE_DIR  ?= wave

SRC_FILES = $(wildcard $(SRC_DIR)/*.v)
TB_FILES = $(wildcard $(SIM_DIR)/*.cpp)

# derive top module name from source files
ifeq ($(words $(SRC_FILES)), 1)
  SRC_FILE := $(firstword $(SRC_FILES))
  MODULE   := $(basename $(notdir $(SRC_FILE)))
else
  MODULE   ?= top
endif

OBJ_MK := V$(MODULE).mk
SIM_TARGET := V$(MODULE)

.PHONY: all run clean help lint gen build wave

help:
	@echo "Usage: make [target]"
	@echo "  lint    - run verilator lint-only"
	@echo "  gen     - generate C++ code from verilog"
	@echo "  build   - generate C++ model and compile"
	@echo "  run     - run simulation"
	@echo "  wave    - run simulation and open GTKWave"
	@echo "  clean   - remove generated files"
	@echo "  all     - build simulator (default target)"


VCD_FILE := $(WAVE_DIR)/$(MODULE).vcd
# 1) Lint-only: Check syntax and style
lint:
	$(VERILATOR) --lint-only -Wall $(SRC_FILES)

# 2) Gen: generate C++ model only (for include resolution)
gen:
	@echo "Generating C++ model for module $(MODULE)..."
	$(VERILATOR) --cc $(SRC_FILES) --trace --Mdir $(OBJ_DIR)

# 3) Build: generate full C++ model with testbenches and compile
build:
	@echo "Generating C++ model with test benches..."
	$(VERILATOR) --cc $(SRC_FILES) $(TB_FILES:%=--exe %) --trace --Mdir $(OBJ_DIR)
	@echo "Compiling simulator binary $(SIM_TARGET)..."
	$(MAKE) -C $(OBJ_DIR) -f $(OBJ_MK) $(SIM_TARGET)

# 4) Run the simulator (produces wave.vcd)
run: build
	@echo "Running simulation for module $(MODULE)..."
	@$(OBJ_DIR)/$(SIM_TARGET)

wave: run
	@echo "Opening GTKWave with $(VCD_FILE)..."
	gtkwave $(VCD_FILE) &

# 5) Clean all generated files
clean:
	rm -rf $(OBJ_DIR)